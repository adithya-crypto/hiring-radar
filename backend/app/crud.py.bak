from typing import List, Dict
from sqlalchemy.orm import Session
from sqlalchemy import desc, or_, func
from .models import Company, HiringScore, JobPosting
from datetime import datetime, timedelta


# ----- Companies -----
def list_companies(db: Session) -> List[Company]:
    return db.query(Company).order_by(Company.name).all()


def company_detail(db: Session, company_id: int) -> Company | None:
    # .get() is deprecated in SA2; use Session.get if you prefer:
    return db.get(Company, company_id)


# ----- Helpers -----
def _recent_apply_urls(db: Session, company_id: int, role_family: str = "SDE", limit: int = 3) -> List[str]:
    rows = (
        db.query(JobPosting.apply_url)
        .filter(
            JobPosting.company_id == company_id,
            JobPosting.role_family == role_family,
            JobPosting.status == "OPEN",
            JobPosting.apply_url.isnot(None),
        )
        .order_by(desc(JobPosting.created_at))
        .limit(limit)
        .all()
    )
    return [r[0] for r in rows if r and r[0]]

def list_company_postings(
    db: Session,
    company_id: int,
    role_family: str = "SDE",
    since_hours: int | None = None,
    since_days: int | None = None,
    limit: int = 500,
):
    q = (
        db.query(JobPosting)
          .filter(
              JobPosting.company_id == company_id,
              JobPosting.status == "OPEN",
          )
    )
    if role_family:
        q = q.filter(JobPosting.role_family == role_family)

    # cutoff logic
    cutoff = None
    if since_hours is not None and since_hours > 0:
        cutoff = datetime.utcnow() - timedelta(hours=since_hours)
    elif since_days is not None and since_days > 0:
        cutoff = datetime.utcnow() - timedelta(days=since_days)

    if cutoff:
        # filter on updated_at first, then created_at as fallback
        q = q.filter(
            or_(
                JobPosting.updated_at >= cutoff,
                JobPosting.created_at >= cutoff,
            )
        )

    rows = q.order_by(desc(JobPosting.updated_at), desc(JobPosting.created_at)).limit(limit).all()

    out = []
    for r in rows:
        out.append({
            "id": r.id,
            "title": r.title,
            "location": r.location,
            "department": r.department,
            "apply_url": r.apply_url,
            "created_at": r.created_at,
            "updated_at": r.updated_at,
            "role_family": r.role_family,
        })
    return out


# ----- Scores -----
def list_scores(db: Session, role_family: str) -> List[Dict]:
    """
    Return the most recent HiringScore per company for the given role_family,
    enriched with a small set of evidence URLs (latest OPEN postings' apply links).
    """
    # get all scores for the role, newest first
    rows = (
        db.query(HiringScore)
        .filter(HiringScore.role_family == role_family)
        .order_by(desc(HiringScore.computed_at), desc(HiringScore.id))
        .all()
    )

    # keep only latest per company
    latest: Dict[int, HiringScore] = {}
    for s in rows:
        if s.company_id not in latest:
            latest[s.company_id] = s

    # shape into JSON-friendly dicts + add evidence links
    out: List[Dict] = []
    for s in latest.values():
        out.append(
            {
                "id": s.id,
                "company_id": s.company_id,
                "role_family": s.role_family,
                "computed_at": s.computed_at,
                "score": s.score,
                "details_json": s.details_json or {},
                "evidence_urls": _recent_apply_urls(db, s.company_id, role_family),
            }
        )

    # sort by score descending (UI expects this)
    out.sort(key=lambda r: r["score"], reverse=True)
    return out

def list_active_top(
    db: Session,
    role_family: str = "SDE",
    limit: int = 50
):
    # subquery: latest score timestamp per company for this role family
    latest_ts = (
        db.query(
            HiringScore.company_id,
            func.max(HiringScore.computed_at).label("max_ts"),
        )
        .filter(HiringScore.role_family == role_family)
        .group_by(HiringScore.company_id)
        .subquery()
    )

    # subquery: latest score rows
    latest_scores = (
        db.query(HiringScore)
        .join(latest_ts,
              (HiringScore.company_id == latest_ts.c.company_id) &
              (HiringScore.computed_at == latest_ts.c.max_ts))
        .subquery()
    )

    # subquery: live open SDE postings per company
    open_counts = (
        db.query(
            JobPosting.company_id.label("cid"),
            func.count().label("open_count"),
        )
        .filter(
            JobPosting.status == "OPEN",
            JobPosting.role_family == role_family
        )
        .group_by(JobPosting.company_id)
        .subquery()
    )

    # join: only companies with open_count > 0, order by score desc, limit
    rows = (
        db.query(
            latest_scores.c.company_id,
            latest_scores.c.role_family,
            latest_scores.c.score,
            latest_scores.c.details_json,
            Company.name.label("company_name"),
            open_counts.c.open_count,
        )
        .join(Company, Company.id == latest_scores.c.company_id)
        .join(open_counts, open_counts.c.cid == latest_scores.c.company_id)
        .filter(open_counts.c.open_count > 0)
        .order_by(desc(latest_scores.c.score), Company.name.asc())
        .limit(limit)
        .all()
    )

    # shape results like /scores rows (plus open_count as convenience)
    return [
        {
            "company_id": r.company_id,
            "role_family": r.role_family,
            "score": r.score,
            "details_json": r.details_json,
            "open_count": int(r.open_count),
            "company_name": r.company_name,
        }
        for r in rows
    ]